{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"How to DAO with DAOstack Introduction DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack , a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. The Stack A DApp build with DAOstack DAOs consists of public blockchain layer ( Infra, Arc, Arc-Hive) which is the source of data caching layers (Subgraph) which allows fast access to the blockchain layer javascript library (Client) for application layer integration.","title":"Home"},{"location":"#how-to-dao-with-daostack","text":"","title":"How to DAO with DAOstack"},{"location":"#introduction","text":"DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack , a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools.","title":"Introduction"},{"location":"#the-stack","text":"A DApp build with DAOstack DAOs consists of public blockchain layer ( Infra, Arc, Arc-Hive) which is the source of data caching layers (Subgraph) which allows fast access to the blockchain layer javascript library (Client) for application layer integration.","title":"The Stack"},{"location":"hackerkit/","text":"Table of contents DAOs Examples Contact and Help DAOs DAOs can be created for any conceivable collaborative purpose, from local political action to distributed manufacturing and sales. The goal of DAOstack is to make it as easy as possible to create and manage DAOs, and to use them to drive a new decentralized global economy (specifically, an economy that uses GEN, our collective attention token ). DAOstack Technologies has created an initial DAO called \"Genesis\" with the purpose of promoting the GEN/DAO ecosystem. Genesis is currently live on the Ethereum mainnet, has over 200 Reputation-holders who have executed over 170 proposals since August 2018, and can be accessed through \"Alchemy\" . Examples The hackers kit is equipped with several examples and sample projects, which we are working to maintain and expand. The goal for these examples is to help developers easily kickstart a new project, as well as to demonstrate some of the features included in each layer of the DAO stack. Starter Template This is a basic template you can use for kickstarting your project using the DAOstack platform. Here you can find the basic structure for using Arc, Client and Subgraph to build your project. Peep DAO This project is a Dapp for interacting with a DAO which has its own DAO social media account on Peepeth , a decentralized microblogging app. The Dapp allows a DAO post Peeps via a decentralized voting mechanism. DutchX DAO Bootstrap This project contains a minimal UI for participating in the bootstrap of the DutchX DAO. The bootstrapping process for a DAO is the process of distributing its initial reputation and tokens. The DutchX bootstrap process is a 3 months period during which users can do several actions, like locking tokens, in order to receive Reputation in the DutchX DAO. You can view the DutchX DAO bootstrapping contracts here . Firestarter DAO Example Firestarter is a community driven crowdsourcing platform, which utilizes DaoStack for governance of the projects. This is a striped down version of the project, which only showcases the DaoStack integration. Contact and Help DAOstack team members and open-source community members always make an effort to assist new projects. For any technical questions, please reach out to us via Discord at this link . If you have any questions or comments about this repository, please open an issue, and we'll do our best to help.","title":"Hacker-kit"},{"location":"hackerkit/#table-of-contents","text":"DAOs Examples Contact and Help","title":"Table of contents"},{"location":"hackerkit/#daos","text":"DAOs can be created for any conceivable collaborative purpose, from local political action to distributed manufacturing and sales. The goal of DAOstack is to make it as easy as possible to create and manage DAOs, and to use them to drive a new decentralized global economy (specifically, an economy that uses GEN, our collective attention token ). DAOstack Technologies has created an initial DAO called \"Genesis\" with the purpose of promoting the GEN/DAO ecosystem. Genesis is currently live on the Ethereum mainnet, has over 200 Reputation-holders who have executed over 170 proposals since August 2018, and can be accessed through \"Alchemy\" .","title":"DAOs"},{"location":"hackerkit/#examples","text":"The hackers kit is equipped with several examples and sample projects, which we are working to maintain and expand. The goal for these examples is to help developers easily kickstart a new project, as well as to demonstrate some of the features included in each layer of the DAO stack.","title":"Examples"},{"location":"hackerkit/#starter-template","text":"This is a basic template you can use for kickstarting your project using the DAOstack platform. Here you can find the basic structure for using Arc, Client and Subgraph to build your project.","title":"Starter Template"},{"location":"hackerkit/#peep-dao","text":"This project is a Dapp for interacting with a DAO which has its own DAO social media account on Peepeth , a decentralized microblogging app. The Dapp allows a DAO post Peeps via a decentralized voting mechanism.","title":"Peep DAO"},{"location":"hackerkit/#dutchx-dao-bootstrap","text":"This project contains a minimal UI for participating in the bootstrap of the DutchX DAO. The bootstrapping process for a DAO is the process of distributing its initial reputation and tokens. The DutchX bootstrap process is a 3 months period during which users can do several actions, like locking tokens, in order to receive Reputation in the DutchX DAO. You can view the DutchX DAO bootstrapping contracts here .","title":"DutchX DAO Bootstrap"},{"location":"hackerkit/#firestarter-dao-example","text":"Firestarter is a community driven crowdsourcing platform, which utilizes DaoStack for governance of the projects. This is a striped down version of the project, which only showcases the DaoStack integration.","title":"Firestarter DAO Example"},{"location":"hackerkit/#contact-and-help","text":"DAOstack team members and open-source community members always make an effort to assist new projects. For any technical questions, please reach out to us via Discord at this link . If you have any questions or comments about this repository, please open an issue, and we'll do our best to help.","title":"Contact and Help"},{"location":"migration/","text":"Migration package is useful for handling the migrations of DAOstack contracts and DAOs. You can use this tool to migrate DAOstack base contracts and DAOstack DAOs in production, test or developer mode","title":"Migration"},{"location":"notes/","text":"Alchmey updates","title":"Notes"},{"location":"gettingStarted/createNewInterface/","text":"Coming Soon","title":"Create your own interface for DAOstack DAOs"},{"location":"gettingStarted/deployDAO/","text":"How to launch a new DAO? The core contracts required by a daostack DAO are already deployed by the DAOstack team on mainnet as well as testnet and the addresses are available in Migration.json . Though you need to deploy an Avatar, custom schemes (optional), native reputation and native token contract. Checkout Structure of DAO for details on Avatar, scheme, rep and token DAO can be deployed using Migration package either from CLI or using javascript. Example deployment setup and scripts are available in Starter-template Choose a name for your DAO and the native token and its symbol Do you want to use DAOcreator contract? Deploying a DAO with DAOcreator contract saves number of transactions to be signed by bundling up founder rep and token distribution (upto 100 members) in single tx and initial scheme registration in single tx Which schemes to include in the DAO? Schemes are the actions a DAOstack DAO can take when a proposal passes/fails. Currently supported schemes in Migrations package are: ContributionReward: Enables fund management proposals that distribute funds to beneficiary once the proposal passes GenericScheme: Enables Avatar to make arbitrary function calls to a specific contract. For eg use Avatar to submit a proposal to Genesis Alpha on behalf of your DAO SchemeRegistrar: Lets you submit a proposal to register more schemes (apart from initial schemes set at time of deployment) to the DAO GlobalConstraintRegistrar: Lets you submit a proposal to register more GlobalConstraints UpgradeScheme: Lets you upgrade the controller. Since Controller is not a Scheme it cannot be changed via SchemeRegistrar Find detailed documentation re Schemes in Arc Repo Ucontroller vs Controller? Refer to documentation on Controllers Decide on which Voting Machine to use and the parameters Set the voting machine parameters according to the needs of the organization. Currently you can deploy a DAO using migrations with only GenesisProtocol voting machine, which allows decision at timeout according to higher relative vote. You can find details about different voting machines supported by arc at https://github.com/daostack/arc/tree/master/docs/contracts/VotingMachines Who gets the initial rep and token in DAO? Edit the list of founder members\u2019 address along with the rep and/or token to be distributed initially. You may choose to give equal rep to all or have differentiated rep. Once you have decided on dao-params follow the instruction in Migrations or one of the examples to deploy your dao","title":"Deploy a DAO"},{"location":"gettingStarted/deployDAO/#how-to-launch-a-new-dao","text":"The core contracts required by a daostack DAO are already deployed by the DAOstack team on mainnet as well as testnet and the addresses are available in Migration.json . Though you need to deploy an Avatar, custom schemes (optional), native reputation and native token contract. Checkout Structure of DAO for details on Avatar, scheme, rep and token DAO can be deployed using Migration package either from CLI or using javascript. Example deployment setup and scripts are available in Starter-template Choose a name for your DAO and the native token and its symbol Do you want to use DAOcreator contract? Deploying a DAO with DAOcreator contract saves number of transactions to be signed by bundling up founder rep and token distribution (upto 100 members) in single tx and initial scheme registration in single tx Which schemes to include in the DAO? Schemes are the actions a DAOstack DAO can take when a proposal passes/fails. Currently supported schemes in Migrations package are: ContributionReward: Enables fund management proposals that distribute funds to beneficiary once the proposal passes GenericScheme: Enables Avatar to make arbitrary function calls to a specific contract. For eg use Avatar to submit a proposal to Genesis Alpha on behalf of your DAO SchemeRegistrar: Lets you submit a proposal to register more schemes (apart from initial schemes set at time of deployment) to the DAO GlobalConstraintRegistrar: Lets you submit a proposal to register more GlobalConstraints UpgradeScheme: Lets you upgrade the controller. Since Controller is not a Scheme it cannot be changed via SchemeRegistrar Find detailed documentation re Schemes in Arc Repo Ucontroller vs Controller? Refer to documentation on Controllers Decide on which Voting Machine to use and the parameters Set the voting machine parameters according to the needs of the organization. Currently you can deploy a DAO using migrations with only GenesisProtocol voting machine, which allows decision at timeout according to higher relative vote. You can find details about different voting machines supported by arc at https://github.com/daostack/arc/tree/master/docs/contracts/VotingMachines Who gets the initial rep and token in DAO? Edit the list of founder members\u2019 address along with the rep and/or token to be distributed initially. You may choose to give equal rep to all or have differentiated rep. Once you have decided on dao-params follow the instruction in Migrations or one of the examples to deploy your dao","title":"How to launch a new DAO?"},{"location":"gettingStarted/setupAlchemyDevMode/","text":"Coming Soon","title":"Add features to Alchemy interface"},{"location":"gettingStarted/setupCustomScheme/","text":"Coming Soon","title":"Add custom scheme to the DAO"},{"location":"gettingStarted/setupCustomSchemeAlchemy/","text":"Coming Soon","title":"Add custom scheme to Alchemy"},{"location":"gettingStarted/setupGenericScheme/","text":"Generic Schemes In DAOstack, \"schemes\" are smart contracts that enable various DAO actions, and \"generic schemes\" are schemes that enable nearly any kind of action possible for an Ethereum address. GenericScheme and UGenericScheme are both types of generic scheme. DAOs can use these schemes: 1) to enable truly generic DAO actions (letting proposers choose which contracts to interact with and how), or 2) to create specific, custom integrations for their DAO (actions that make particular calls to particular smart contracts that serve a particular purpose for the DAO). When to use GenericScheme and when to use UGenericScheme UGenericScheme : If a DAO only needs a single generic scheme and/or doesn't need to change the scheme's on-chain code at all, then the UGenericScheme is a good choice, since it is already deployed and can be used by any number of DAOs (the \"U\" stands for \"universal\"). GenericScheme : If a DAO wants to make multiple smart contracts available, with different labels and proposal types in the UI, then each contract should use its own GenericScheme, customized if required for the DAO's purpose. NOTE: While at the contract level, both generic schemes only need encoded call data to function, asking users to provide this data is not good UX. If you're using a generic scheme for anything except a truly generic action, which is only accessible to Ethereum experts, we ask that you add Alchemy support for the specific actions you intend. Please do not register your scheme on mainnet without adding alchemy support for it. Here is an example of a customized generic scheme on mainnet. How to register a generic scheme to a DAO A DAO can only use schemes that are registered with its controller. There are two ways to register a scheme to a DAO's controller: During the DAO's creation, while deploying the DAO's contracts Through a proposal that uses a scheme with permission to register schemes to the DAO. NOTE: In case of the Genesis DAO, you can propose new schemes to be registered using the aptly named Scheme Registrar scheme. Register a generic scheme while deploying a DAO While deploying DAO, \" UGenericScheme \" can be used to register the universal generic scheme. If are using the regular GenericScheme, then you can register multiple \" GenericScheme \" instances and mention each in the customSchemes section of your migration-dao-params.json . Refer to the instructions for how to deploy DAO . Register a generic scheme via another Scheme Set UGenericScheme to interact with your contract NOTE: Follow this if UGenericScheme is not already registered in your DAO or you need to update UGenericScheme with new parameters. You can use UGenericScheme's setParameters method to setup the contractToCall , the votingMachine to use, and the voteParameters used for voting on proposals for the generic scheme action. The following is a short script that shows how to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 const ugenericScheme = new web3 . eth . Contract ( require ( @daostack/arc/build/contracts/UGenericScheme.json ). abi , UGenericSchemeAddress , // address from https://github.com/daostack/migration/blob/master/migration.json { from , gas , gasPrice } ) // These are example values: please change appropriately. // Refer to https://daostack.zendesk.com/hc/en-us/sections/360000535638-Genesis-Protocol const voteParams = { boostedVotePeriodLimit : 345600 , daoBountyConst : 10 , minimumDaoBountyGWei : 150000000000 , queuedVotePeriodLimit : 2592000 , queuedVoteRequiredPercentage : 50 , preBoostedVotePeriodLimit : 86400 , proposingRepRewardGwei : 50000000000 , quietEndingPeriod : 172800 , thresholdConst : 1200 , voteOnBehalf : 0x0000000000000000000000000000000000000000 , votersReputationLossRatio : 4 , activationTime : 0 } // Get address from https://github.com/daostack/migration/blob/master/migration.json const votingMachineAddress = 0xaddress-of-VotingMachine-of-DAO-on-given-network // If you want this Generic Scheme to enable DAO to interact with Bounties Network // then targetContract would be the address of Bounties Network s respective contract const targetContractAddress = 0xaddress-of-contract-this-will-interact-with // paramHash will be useful in later step so lets log it const paramHash = ugenericScheme . methods . setParameters ( voteParams , votingMachineAddress , targetContractAddress ). call () console . log ( paramHash ) ugenericScheme . methods . setParameters ( voteParams , votingMachineAddress , targetContractAddress ). send () OR Set GenericScheme to interact with your contract First, you will have to deploy a new instance of GenericScheme and use its initialize method to setup its params: the DAO Avatar it connects to, the contractToCall , the votingMachine to use, and the voteParameters for voting on proposals that use the scheme. The following is a short script that shows how to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 const genericSchemeJson = require ( @daostack/arc/build/contracts/GenericScheme.json ) const genericSchemeContract = new web3 . eth . Contract ( genericSchemeJson . abi , undefined , { from , gas , gasPrice } ) // Deploy New GenericScheme Instance const genericSchemeDeployedContract = genericSchemeContract . deploy ({ data : genericSchemeJson . bytecode , arguments : null }). send () let genericScheme = await genericSchemeDeployedContract // Log Address of new instance to use in next step while registering the scheme to DAO console . log ( `Deployed new GenericScheme instance at ${ genericScheme . options . address } ` ) // Following are example values, Please change appropriately // Refer https://daostack.zendesk.com/hc/en-us/sections/360000535638-Genesis-Protocol const voteParams = { boostedVotePeriodLimit : 345600 , daoBountyConst : 10 , minimumDaoBountyGWei : 150000000000 , queuedVotePeriodLimit : 2592000 , queuedVoteRequiredPercentage : 50 , preBoostedVotePeriodLimit : 86400 , proposingRepRewardGwei : 50000000000 , quietEndingPeriod : 172800 , thresholdConst : 1200 , voteOnBehalf : 0x0000000000000000000000000000000000000000 , votersReputationLossRatio : 4 , activationTime : 0 } // Get address from https://github.com/daostack/migration/blob/master/migration.json const votingMachineAddress = 0xaddress-of-VotingMachine-of-DAO-on-given-network // For eg if you want this Generic Scheme to enable DAO to interact with Bounties Network // then targetContract would be the address of Bounties Network s respective contract const targetContractAddress = 0xaddress-of-contract-this-will-interact-with const avatar = 0xaddres-of-DAO // paramHash will be useful in later step so lets log it const paramHash = genericScheme . methods . initialize ( avatar , voteParams , votingMachineAddress , targetContractAddress ). call () console . log ( paramHash ) genericScheme . methods . initialize ( avatar , voteParams , votingMachineAddress , targetContractAddress ). send () Submit a new proposal to the Scheme Registrar via Alchemy UI On Alchemy's landing page, choose the DAO to which you wish to register the scheme. Visit the DAO's Home page and choose Scheme Registrar . Click New Proposal \u2013 this will open a popup. Select Add Scheme on the popup sidebar (on the left). Give the proposal an appropriate title, description, and url linking to a description of the proposal. For Scheme , put the address of your Generic Scheme contract (universal or not). Enter the paramHash you got here . In the permissions section, check Call genericCall on behalf of (this will allow your scheme to make generic calls, which is the whole point here). Submit the proposal and sign the transaction as normal. If the DAO passes your proposal, then your Generic Scheme with the ability to interact with the targetContract will be registered to the DAO, and people will be able to submit proposals for the DAO to take your custom generic action. How to get Generic Scheme indexed by DAOstack subgraph The DAOstack subgraph enables Alchemy's quick loading of cached blockchain data and is a huge part of creating a positive user experience in Alchemy. If you are using: UGenericScheme: the subgraph is already indexing the scheme, and you do not have to worry about it \ud83d\ude05 GenericScheme: You will have to submit a PR here Make sure to choose the correct Ethereum network for your DAO If the scheme is for a new DAO, then add YourDAO.json in that network folder. eg. 1 2 3 4 5 6 7 8 9 10 11 { name : New DAO , Avatar : 0xaddress-of-avatar-on-this-network , DAOToken : 0xaddress-of-daotoken-on-this-network , Reputation : 0xaddress-of-nativereputation-on-this-network , Controller : 0xaddress-of-controller-on-this-network , Schemes : { GenesisScheme : 0xaddress-of-genericScheme-on-this-network } , arcVersion : 0.0.1-rc.22 # choose the correct arc version } If the scheme is for an already existing DAO, then edit existing-DAO .json for the correct network. Add to the schemes section, eg. 1 2 3 4 Schemes : { GenesisScheme : 0xaddress-of-genericScheme-on-this-network } , arcVersion : 0.0.1-rc.22 # choose the correct arc version How to get your Generic Scheme showing up in Alchemy To help you get a user-friendly interface for your generic scheme, we have created a way to customize Alchemy's UI for specific generic schemes. The customization has a few pieces, and you will have to submit a PR to the Alchemy repo once you're finished with it. Proposal Creation Interface Customize the \"create proposal\" popup to present the different functions the scheme can call on the contract. This requires adding the contracts\u2019 ABI and customizing things like the titles of the labels and placeholders. If this was a generic scheme for interacting with the Bounties Network, you would create a file named something like Bounties.json and add it here . Use the following example or refer to an example using the DutchX integration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Bounties.json { name : Bounties , address : { main : [ 0xtarget-contract-address-on-mainnet ], rinkeby : [], private : [] }, actions : [ { id : createBountyMethod-from-contract , label : Create Bounty , description : This method will create a bounty with the DAO as the issuer , notes : , fields : [ { label : bounty title , name : name-of-field-in-abi , placeholder : Osam Bin-Laden - dead or alive }, { // more feilds if any }, ], abi : {}, }, { // more methods of contract if any } ], } Proposal Display Interface You will also have to customize the description summary for your scheme to explain what it does. Refer to the ProposalSummaryDutchX and add your own proposal summary file, say ProposalSummaryBountiesNetwork.tsx , here . (Optional) Change the Scheme UI Right now, Alchemy\u2019s UI is only focused on currently open proposals (it does not show past proposals). But based on the scheme you are adding, there might be some different UI features/tabs that are required. For a bounties scheme, for example, it would be helpful to have a new tab that shows open bounties (from proposals that have already been passed).","title":"Setup Generic Scheme for a DAO"},{"location":"gettingStarted/setupGenericScheme/#generic-schemes","text":"In DAOstack, \"schemes\" are smart contracts that enable various DAO actions, and \"generic schemes\" are schemes that enable nearly any kind of action possible for an Ethereum address. GenericScheme and UGenericScheme are both types of generic scheme. DAOs can use these schemes: 1) to enable truly generic DAO actions (letting proposers choose which contracts to interact with and how), or 2) to create specific, custom integrations for their DAO (actions that make particular calls to particular smart contracts that serve a particular purpose for the DAO).","title":"Generic Schemes"},{"location":"gettingStarted/setupGenericScheme/#when-to-use-genericscheme-and-when-to-use-ugenericscheme","text":"UGenericScheme : If a DAO only needs a single generic scheme and/or doesn't need to change the scheme's on-chain code at all, then the UGenericScheme is a good choice, since it is already deployed and can be used by any number of DAOs (the \"U\" stands for \"universal\"). GenericScheme : If a DAO wants to make multiple smart contracts available, with different labels and proposal types in the UI, then each contract should use its own GenericScheme, customized if required for the DAO's purpose. NOTE: While at the contract level, both generic schemes only need encoded call data to function, asking users to provide this data is not good UX. If you're using a generic scheme for anything except a truly generic action, which is only accessible to Ethereum experts, we ask that you add Alchemy support for the specific actions you intend. Please do not register your scheme on mainnet without adding alchemy support for it. Here is an example of a customized generic scheme on mainnet.","title":"When to use GenericScheme and when to use UGenericScheme"},{"location":"gettingStarted/setupGenericScheme/#how-to-register-a-generic-scheme-to-a-dao","text":"A DAO can only use schemes that are registered with its controller. There are two ways to register a scheme to a DAO's controller: During the DAO's creation, while deploying the DAO's contracts Through a proposal that uses a scheme with permission to register schemes to the DAO. NOTE: In case of the Genesis DAO, you can propose new schemes to be registered using the aptly named Scheme Registrar scheme.","title":"How to register a generic scheme to a DAO"},{"location":"gettingStarted/setupGenericScheme/#register-a-generic-scheme-while-deploying-a-dao","text":"While deploying DAO, \" UGenericScheme \" can be used to register the universal generic scheme. If are using the regular GenericScheme, then you can register multiple \" GenericScheme \" instances and mention each in the customSchemes section of your migration-dao-params.json . Refer to the instructions for how to deploy DAO .","title":"Register a generic scheme while deploying a DAO"},{"location":"gettingStarted/setupGenericScheme/#register-a-generic-scheme-via-another-scheme","text":"","title":"Register a generic scheme via another Scheme"},{"location":"gettingStarted/setupGenericScheme/#set-ugenericscheme-to-interact-with-your-contract","text":"NOTE: Follow this if UGenericScheme is not already registered in your DAO or you need to update UGenericScheme with new parameters. You can use UGenericScheme's setParameters method to setup the contractToCall , the votingMachine to use, and the voteParameters used for voting on proposals for the generic scheme action. The following is a short script that shows how to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 const ugenericScheme = new web3 . eth . Contract ( require ( @daostack/arc/build/contracts/UGenericScheme.json ). abi , UGenericSchemeAddress , // address from https://github.com/daostack/migration/blob/master/migration.json { from , gas , gasPrice } ) // These are example values: please change appropriately. // Refer to https://daostack.zendesk.com/hc/en-us/sections/360000535638-Genesis-Protocol const voteParams = { boostedVotePeriodLimit : 345600 , daoBountyConst : 10 , minimumDaoBountyGWei : 150000000000 , queuedVotePeriodLimit : 2592000 , queuedVoteRequiredPercentage : 50 , preBoostedVotePeriodLimit : 86400 , proposingRepRewardGwei : 50000000000 , quietEndingPeriod : 172800 , thresholdConst : 1200 , voteOnBehalf : 0x0000000000000000000000000000000000000000 , votersReputationLossRatio : 4 , activationTime : 0 } // Get address from https://github.com/daostack/migration/blob/master/migration.json const votingMachineAddress = 0xaddress-of-VotingMachine-of-DAO-on-given-network // If you want this Generic Scheme to enable DAO to interact with Bounties Network // then targetContract would be the address of Bounties Network s respective contract const targetContractAddress = 0xaddress-of-contract-this-will-interact-with // paramHash will be useful in later step so lets log it const paramHash = ugenericScheme . methods . setParameters ( voteParams , votingMachineAddress , targetContractAddress ). call () console . log ( paramHash ) ugenericScheme . methods . setParameters ( voteParams , votingMachineAddress , targetContractAddress ). send ()","title":"Set UGenericScheme to interact with your contract"},{"location":"gettingStarted/setupGenericScheme/#or","text":"","title":"OR"},{"location":"gettingStarted/setupGenericScheme/#set-genericscheme-to-interact-with-your-contract","text":"First, you will have to deploy a new instance of GenericScheme and use its initialize method to setup its params: the DAO Avatar it connects to, the contractToCall , the votingMachine to use, and the voteParameters for voting on proposals that use the scheme. The following is a short script that shows how to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 const genericSchemeJson = require ( @daostack/arc/build/contracts/GenericScheme.json ) const genericSchemeContract = new web3 . eth . Contract ( genericSchemeJson . abi , undefined , { from , gas , gasPrice } ) // Deploy New GenericScheme Instance const genericSchemeDeployedContract = genericSchemeContract . deploy ({ data : genericSchemeJson . bytecode , arguments : null }). send () let genericScheme = await genericSchemeDeployedContract // Log Address of new instance to use in next step while registering the scheme to DAO console . log ( `Deployed new GenericScheme instance at ${ genericScheme . options . address } ` ) // Following are example values, Please change appropriately // Refer https://daostack.zendesk.com/hc/en-us/sections/360000535638-Genesis-Protocol const voteParams = { boostedVotePeriodLimit : 345600 , daoBountyConst : 10 , minimumDaoBountyGWei : 150000000000 , queuedVotePeriodLimit : 2592000 , queuedVoteRequiredPercentage : 50 , preBoostedVotePeriodLimit : 86400 , proposingRepRewardGwei : 50000000000 , quietEndingPeriod : 172800 , thresholdConst : 1200 , voteOnBehalf : 0x0000000000000000000000000000000000000000 , votersReputationLossRatio : 4 , activationTime : 0 } // Get address from https://github.com/daostack/migration/blob/master/migration.json const votingMachineAddress = 0xaddress-of-VotingMachine-of-DAO-on-given-network // For eg if you want this Generic Scheme to enable DAO to interact with Bounties Network // then targetContract would be the address of Bounties Network s respective contract const targetContractAddress = 0xaddress-of-contract-this-will-interact-with const avatar = 0xaddres-of-DAO // paramHash will be useful in later step so lets log it const paramHash = genericScheme . methods . initialize ( avatar , voteParams , votingMachineAddress , targetContractAddress ). call () console . log ( paramHash ) genericScheme . methods . initialize ( avatar , voteParams , votingMachineAddress , targetContractAddress ). send ()","title":"Set GenericScheme to interact with your contract"},{"location":"gettingStarted/setupGenericScheme/#submit-a-new-proposal-to-the-scheme-registrar-via-alchemy-ui","text":"On Alchemy's landing page, choose the DAO to which you wish to register the scheme. Visit the DAO's Home page and choose Scheme Registrar . Click New Proposal \u2013 this will open a popup. Select Add Scheme on the popup sidebar (on the left). Give the proposal an appropriate title, description, and url linking to a description of the proposal. For Scheme , put the address of your Generic Scheme contract (universal or not). Enter the paramHash you got here . In the permissions section, check Call genericCall on behalf of (this will allow your scheme to make generic calls, which is the whole point here). Submit the proposal and sign the transaction as normal. If the DAO passes your proposal, then your Generic Scheme with the ability to interact with the targetContract will be registered to the DAO, and people will be able to submit proposals for the DAO to take your custom generic action.","title":"Submit a new proposal to the Scheme Registrar via Alchemy UI"},{"location":"gettingStarted/setupGenericScheme/#how-to-get-generic-scheme-indexed-by-daostack-subgraph","text":"The DAOstack subgraph enables Alchemy's quick loading of cached blockchain data and is a huge part of creating a positive user experience in Alchemy. If you are using: UGenericScheme: the subgraph is already indexing the scheme, and you do not have to worry about it \ud83d\ude05 GenericScheme: You will have to submit a PR here Make sure to choose the correct Ethereum network for your DAO If the scheme is for a new DAO, then add YourDAO.json in that network folder. eg. 1 2 3 4 5 6 7 8 9 10 11 { name : New DAO , Avatar : 0xaddress-of-avatar-on-this-network , DAOToken : 0xaddress-of-daotoken-on-this-network , Reputation : 0xaddress-of-nativereputation-on-this-network , Controller : 0xaddress-of-controller-on-this-network , Schemes : { GenesisScheme : 0xaddress-of-genericScheme-on-this-network } , arcVersion : 0.0.1-rc.22 # choose the correct arc version } If the scheme is for an already existing DAO, then edit existing-DAO .json for the correct network. Add to the schemes section, eg. 1 2 3 4 Schemes : { GenesisScheme : 0xaddress-of-genericScheme-on-this-network } , arcVersion : 0.0.1-rc.22 # choose the correct arc version","title":"How to get Generic Scheme indexed by DAOstack subgraph"},{"location":"gettingStarted/setupGenericScheme/#how-to-get-your-generic-scheme-showing-up-in-alchemy","text":"To help you get a user-friendly interface for your generic scheme, we have created a way to customize Alchemy's UI for specific generic schemes. The customization has a few pieces, and you will have to submit a PR to the Alchemy repo once you're finished with it.","title":"How to get your Generic Scheme showing up in Alchemy"},{"location":"gettingStarted/setupGenericScheme/#proposal-creation-interface","text":"Customize the \"create proposal\" popup to present the different functions the scheme can call on the contract. This requires adding the contracts\u2019 ABI and customizing things like the titles of the labels and placeholders. If this was a generic scheme for interacting with the Bounties Network, you would create a file named something like Bounties.json and add it here . Use the following example or refer to an example using the DutchX integration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Bounties.json { name : Bounties , address : { main : [ 0xtarget-contract-address-on-mainnet ], rinkeby : [], private : [] }, actions : [ { id : createBountyMethod-from-contract , label : Create Bounty , description : This method will create a bounty with the DAO as the issuer , notes : , fields : [ { label : bounty title , name : name-of-field-in-abi , placeholder : Osam Bin-Laden - dead or alive }, { // more feilds if any }, ], abi : {}, }, { // more methods of contract if any } ], }","title":"Proposal Creation Interface"},{"location":"gettingStarted/setupGenericScheme/#proposal-display-interface","text":"You will also have to customize the description summary for your scheme to explain what it does. Refer to the ProposalSummaryDutchX and add your own proposal summary file, say ProposalSummaryBountiesNetwork.tsx , here .","title":"Proposal Display Interface"},{"location":"gettingStarted/setupGenericScheme/#optional-change-the-scheme-ui","text":"Right now, Alchemy\u2019s UI is only focused on currently open proposals (it does not show past proposals). But based on the scheme you are adding, there might be some different UI features/tabs that are required. For a bounties scheme, for example, it would be helpful to have a new tab that shows open bounties (from proposals that have already been passed).","title":"(Optional) Change the Scheme UI"},{"location":"stack/alchemy/alchemyIntro/","text":"The Client library facilitates development of \"Dapps\" (Decentralized applications) for interacting with DAOs. DAOstack has built its own Dapp called Alchemy , a front-end interface for DAOs , or more specifically, for budget management in decentralized organizations. Alchemy allows end users to make collaborative budgeting decisions and allocations using the Holographic Consensus protocol . You can find the Alchemy repo at github.com/daostack/alchemy . A second Dapp built by DAOstack is Vanille (enable MetaMask). Vanille enables users to create and interact with DAOs before moving to a dedicated interface like Alchemy. You can find the Vanille repo here: https://github.com/daostack/vanille . Should I work at this level? Build at the Dapp level if you want to create new ways to interact with existing DAOs and DAOstack smart contracts, e.g. a multi-DAO explorer for GEN predictors or a new DAO creation app.","title":"DApps/Alchemy"},{"location":"stack/alchemy/alchemyIntro/#should-i-work-at-this-level","text":"Build at the Dapp level if you want to create new ways to interact with existing DAOs and DAOstack smart contracts, e.g. a multi-DAO explorer for GEN predictors or a new DAO creation app.","title":"Should I work at this level?"},{"location":"stack/arc/arcIntro/","text":"Arc is a Solidity smart contract library for building DAOs. To get a good understanding of how the Arc framework is built, you can go to this blog post . Arc uses Infra to provide decentralized organizations with voting machines and voting rights management systems. DAOs built with Arc have a few basic contract components: Avatar - The DAO's \"account.\" This contract represents the address of the DAO and holds its assets. Reputation - Voting in Arc is done mainly using Reputation. Reputation can be distributed and redistributed only by DAO decision, and it is generally given (via vote) to an agent according to their performance and contribution to a DAO. Token - Each DAO may have its own token, which can be used in any way the DAO would like. Controller - The controller is the \"Access Control\" of the DAO, managing who can interact with which DAO functions and enforcing the DAO's constraints. Schemes - Schemes are a DAO's \"actions\": anything a DAO should act upon needs to be written and authorized by the controller as a scheme. Schemes might be used to help a DAO: propose and make investments, give reputation to agents, upgrade the DAO's contracts, register new schemes and constraints, etc. Global Constraints - Global constraints are limitations on a DAO's actions. When executing a scheme, the controller checks the constraints to see if the action violates them, and blocks the execution if it does. Some examples for constraints might be: the token supply can't be increased over 1M tokens, the organization won't use more than 60% of its funds at once, etc. Arc utilizes the concept of \"Universal\" contracts : contracts which are deployed once, and then can be used by any number of DAOs simultaneously, saving gas and deployment costs. Schemes and constraints can both be used in this way. To use the already deployed contracts, you can either use Client, which maintains easy access to all universal Arc contracts, or you can use Migration.json to view the addresses of the universal contracts of the latest arc version on the mainnet, Kovan, Rinkeby and Ganache* All contracts listed in the file are universal, meaning that users should use them when needed and not redeploy them. * Please note that the Ganache addresses are based on the DAOstack commands for running and deploying Arc to a local Ganache network, which means those addresses might change if you are using a different method to run Ganache or deploy Arc. Should I work at this level? Using Arc is not necessary to deploy a DAO (you can do this with Migrations currently and in the future as an end user of Dapps), but you might want to work on this layer if you need your DAO to have a unique action, constraint, or voting process that is not yet implemented on Arc. You can find the complete Arc docs here: https://daostack.github.io/arc","title":"Arc"},{"location":"stack/arc/arcIntro/#should-i-work-at-this-level","text":"Using Arc is not necessary to deploy a DAO (you can do this with Migrations currently and in the future as an end user of Dapps), but you might want to work on this layer if you need your DAO to have a unique action, constraint, or voting process that is not yet implemented on Arc. You can find the complete Arc docs here: https://daostack.github.io/arc","title":"Should I work at this level?"},{"location":"stack/client/clientIntro/","text":"Client is a library that facilitates access to Arc contracts without having to directly interact with the Ethereum blockchain. It provides functions to interact with DAOstack contracts to vote, propose, stake and execute proposals. Client library is also a wrapper around DAOstack subgraph . It enable developers to interact with subgraph and execute various generic graph queries to access proposals, daos and other complex entities Using Client, JavaScript/TypeScript developers can easily write scripts or applications which can interact with existing DAOs, submit proposals to DAOs, vote and stake on proposals, execute the resulting decisions, manage agent reputations. This is particularly helpful for developers who want to get the advantages of decentralized governance on the blockchain without dealing directly with a smart contract language. Should I work at this level? You should use Client whenever you want to use JavaScript or TypeScript to interact with Arc contracts for voting, proposing etc or to execute generic GraphQL queries on subgraph for accessing blockchain data. If you are interacting with custom Arc contracts or custom subgraph, then you might have to write your own Web3 library to interact with contracts and/or query the subgraph.","title":"Client"},{"location":"stack/client/clientIntro/#should-i-work-at-this-level","text":"You should use Client whenever you want to use JavaScript or TypeScript to interact with Arc contracts for voting, proposing etc or to execute generic GraphQL queries on subgraph for accessing blockchain data. If you are interacting with custom Arc contracts or custom subgraph, then you might have to write your own Web3 library to interact with contracts and/or query the subgraph.","title":"Should I work at this level?"},{"location":"stack/infra/infraIntro/","text":"Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predifined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built. Should I work at this level? Build on Infra if you need new or modified decentralized governance primitives, such as voting machines and voting rights management systems.","title":"Infra"},{"location":"stack/infra/infraIntro/#should-i-work-at-this-level","text":"Build on Infra if you need new or modified decentralized governance primitives, such as voting machines and voting rights management systems.","title":"Should I work at this level?"},{"location":"stack/subgraph/subgraphIntro/","text":"Subgraph indexes the blockchain data and stores it in postgres database for easy and quick access. The subgraph runs on a Graph Node which is a server that developers can run local or remote. The data store can be queried by GraphQL endpoints. DAOstack subgraph is based on graphprotocol, checkout TheGraph for more details. TheGraph opens their server to others and you can find daostack subgraph and subgraphs from many other projects at Graph Explorer Should I work at this level? If you are writing new Arc contracts which are not indexed by DAOstack subgraph or want to fetch data of existing Arc contracts in a way other than that specified in DAOstack subgraph's schema.graphql , then you should write your own subgraph schema and mappings","title":"Subgraph"},{"location":"stack/subgraph/subgraphIntro/#should-i-work-at-this-level","text":"If you are writing new Arc contracts which are not indexed by DAOstack subgraph or want to fetch data of existing Arc contracts in a way other than that specified in DAOstack subgraph's schema.graphql , then you should write your own subgraph schema and mappings","title":"Should I work at this level?"}]}